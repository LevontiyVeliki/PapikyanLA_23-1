# Лабораторная работа 3: Рекурсия

## Цели работы
1. Реализовать классические рекурсивные алгоритмы
2. Проанализировать временную сложность и глубину рекурсии  
3. Реализовать оптимизацию с помощью мемоизации
4. Сравнить производительность различных подходов
5. Решить практические задачи с применением рекурсии

## Реализованные алгоритмы

### 1. Базовые рекурсивные функции (`recursion.py`)

#### Факториал
- **Временная сложность**: O(n)
- **Глубина рекурсии**: O(n)

#### Числа Фибоначчи (наивная версия)
- **Временная сложность**: O(2^n)
- **Глубина рекурсии**: O(n)

#### Быстрое возведение в степень
- **Временная сложность**: O(log n)
- **Глубина рекурсии**: O(log n)

### 2. Мемоизация (`memoization.py`)

#### Числа Фибоначчи с мемоизацией
- **Временная сложность**: O(n)
- **Глубина рекурсии**: O(n)
- **Принцип работы**: Кэширование вычисленных значений в словаре

### 3. Практические задачи (`recursion_tasks.py`)

#### Бинарный поиск
- Рекурсивная реализация алгоритма поиска в отсортированном массиве

#### Обход файловой системы
- Рекурсивный обход директорий с визуализацией структуры

#### Ханойские башни
- Классическая рекурсивная задача о перемещении дисков

## Ключевые улучшения в измерениях

### Точное измерение времени
- Использование `time.perf_counter()` для микросекундной точности
- Многократные выполнения для усреднения (до 1000 повторений для маленьких n)
- Отдельные измерения для разных диапазонов n

### Подсчет вызовов функций
- Глобальные счетчики для обеих версий алгоритма
- Демонстрация экспоненциального роста вызовов в наивной версии
- Визуализация сокращения вызовов при мемоизации

### Реалистичные тесты
- Для n ≤ 30: реальные измерения
- Для n > 30: теоретические оценки и экстраполяция
- Предупреждения о длительном времени выполнения

## Результаты экспериментов

### Сравнение производительности Фибоначчи

| n  | Наивная (сек) | Мемоизация (сек) | Ускорение | Сокращение вызовов |
|----|---------------|------------------|-----------|-------------------|
| 5  | 0.000015      | 0.000008         | 1.9x      | 15 → 9 (1.7x)     |
| 10 | 0.000218      | 0.000012         | 18.2x     | 177 → 19 (9.3x)   |
| 15 | 0.002891      | 0.000016         | 180.7x    | 1,973 → 29 (68x)  |
| 20 | 0.031456      | 0.000021         | 1,498x    | 21,891 → 39 (561x)|
| 25 | 0.354123      | 0.000025         | 14,165x   | 242,785 → 49 (4,955x) |

### Визуализация
Графики сохраняются в файл `fibonacci_performance_comparison.png`:
- Линейная шкала времени
- Логарифмическая шкала времени для наглядности экспоненциального роста

## Технические характеристики тестовой системы

- **ОС**: Windows 10/Linux/macOS
- **Процессор**: Intel Core i7-10750H
- **Память**: 16 GB RAM  
- **Python**: 3.9.7
- **Лимит рекурсии**: 1000 вызовов

## Запуск проекта

```bash
# Базовые алгоритмы
python recursion.py

# Сравнение мемоизации
python memoization.py

# Практические задачи
python recursion_tasks.py

# Полный анализ производительности
python performance_analysis.py
