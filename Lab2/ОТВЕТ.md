Лабораторная работа 2: Основные структуры данных
Цель работы
Изучить понятие и особенности базовых абстрактных типов данных (стек, очередь, дек, связный список) и их реализаций в Python. Научиться выбирать оптимальную структуру данных для решения конкретной задачи, основываясь на анализе теоретической и практической сложности операций.

Теоретическая часть
Основные структуры данных и их сложность операций
Структура данных	Вставка в начало	Вставка в конец	Доступ по индексу	Удаление из начала	Поиск
List (Python)	O(n)	O(1)    O(1)	  O(n)	O(n)
LinkedList	O(1)	  O(n)  	O(n)	  O(1)	O(n)
Deque	O(1)	O(1)	  O(n)	  O(1)	  O(n)
*амортизированная сложность
**с использованием tail-указателя

# Ответы на контрольные вопросы

## 1. Ключевое отличие динамического массива от связного списка

**Динамический массив (Python list):**
- **Вставка в начало**: O(n) - требует сдвига всех элементов
- **Доступ по индексу**: O(1) - прямое обращение по адресу

**Связный список:**
- **Вставка в начало**: O(1) - только изменение указателей
- **Доступ по индексу**: O(n) - требуется последовательный проход

**Объяснение:** Динамический массив хранит элементы в непрерывном блоке памяти, что обеспечивает быстрый доступ по индексу, но делает вставку в начало дорогой операцией. Связный список состоит из отдельных узлов с указателями, что делает вставку в начало быстрой, но доступ по индексу медленным.

## 2. Принцип работы стека (LIFO) и очереди (FIFO)

**Стек (LIFO - Last In, First Out):**
- **Принцип**: Последний добавленный элемент извлекается первым
- **Основные операции**: push (добавить), pop (извлечь)
- **Примеры использования**:
  1. **Система отмены действий** - последнее действие отменяется первым
  2. **Вызов функций** - стек вызовов хранит информацию о текущих функциях

**Очередь (FIFO - First In, First Out):**
- **Принцип**: Первый добавленный элемент извлекается первым
- **Основные операции**: enqueue (добавить), dequeue (извлечь)
- **Примеры использования**:
  1. **Очередь печати** - документы печатаются в порядке поступления
  2. **Обработка запросов** - сервер обрабатывает запросы в порядке получения

## 3. Сложность удаления первого элемента: list vs deque

**list в Python (O(n)):**
```python
# При удалении первого элемента все остальные элементы
# должны быть сдвинуты на одну позицию влево
[1, 2, 3, 4, 5] → [2, 3, 4, 5]
# Требуется O(n) операций для перемещения n-1 элементов
```

**deque (O(1)):**
```python
# deque реализован как двусвязный список
# Удаление первого элемента требует только
# обновления нескольких указателей
A ↔ B ↔ C ↔ D  →  B ↔ C ↔ D
# Требуется O(1) операций независимо от размера
```

## 4. Структура данных для системы отмены действий

**Рекомендуемая структура: Стек**

**Обоснование выбора:**

1. **Соответствие LIFO**: Система отмены естественно соответствует принципу "последний пришел - первый ушел"
2. **Эффективность операций**:
   - Добавление действия: O(1)
   - Отмена последнего действия: O(1)
3. **Простота реализации**:
   ```python
   class TextEditor:
       def __init__(self):
           self.undo_stack = []
           self.redo_stack = []
       
       def perform_action(self, action):
           self.undo_stack.append(action)
           self.redo_stack.clear()  # Очистить redo при новом действии
       
       def undo(self):
           if self.undo_stack:
               action = self.undo_stack.pop()
               action.undo()
               self.redo_stack.append(action)
       
       def redo(self):
           if self.redo_stack:
               action = self.redo_stack.pop()
               action.perform()
               self.undo_stack.append(action)
   ```

**Альтернативы и почему они хуже:**
- **Очередь (FIFO)**: Не соответствует логике отмены последнего действия
- **Массив**: Менее эффективные операции добавления/удаления
- **Связный список**: Избыточная сложность для данной задачи

## 5. Объяснение результатов вставки 1000 элементов

**Асимптотическая сложность операций:**

**Динамический массив (list):**
```python
# Каждая вставка в начало требует O(n) операций
# Общая сложность для k вставок: O(1 + 2 + 3 + ... + k) = O(k²)
for i in range(1000):
    my_list.insert(0, i)  # Каждая вставка требует сдвига всех элементов
```

**Связный список:**
```python
# Каждая вставка в начало требует O(1) операций
# Общая сложность для k вставок: O(k)
for i in range(1000):
    my_linked_list.prepend(i)  # Только создание узла и обновление указателей
```

**Количественное сравнение:**

| Операция | list (динамический массив) | Связный список |
|----------|---------------------------|----------------|
| **1 вставка** | O(n) | O(1) |
| **1000 вставок** | O(n²) ≈ 500,000 операций | O(n) = 1000 операций |
| **Общее время** | Значительно больше | Значительно меньше |

**Вывод:** Результаты полностью соответствуют теоретической оценке сложности. Связный список демонстрирует линейную сложность O(n) для n вставок, тогда как динамический массив показывает квадратичную сложность O(n²), что объясняет значительную разницу во времени выполнения.
